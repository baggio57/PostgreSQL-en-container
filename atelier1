rappel :

Un opérateur est un outil logiciel qui élargit les fonctionnalités de Kubernetes afin de gérer spécifiquement un type de ressource ou d’application.
Garce à cet opérateur, et notamment CloudNativePG, il nous est possible de déployer facilement une instance PostgreSQL dans notre cluster Kubernetes.

pre-requis :
- le cluster est opérationnel
- l'opérateur CloudNativePG est installé

Déployer une instance :

contenu de mon premier fichier yaml :
---
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: postgresql
spec:
  imageName: ghcr.io/cloudnative-pg/postgresql:17.0
  instances: 1
  storage:
    size: 20Gi

Pour appliquer ce fichier, il suffit d'executer la commande : kubectl apply -f .\moncluster.yaml
Quelques temps apres, notre cluster postgresql est UP (kubectl get cluster) :

postgresql       12m   1           1       Cluster in healthy state   postgresql-1

La commande : kubectl get pod posgtresql-1 => nous montre le status de notre pod :

NAME           READY   STATUS    RESTARTS   AGE
postgresql-1   1/1     Running   0          14m

-------------------------------------

Déployer une instance secondaire :

Il suffit de modifier notre fichier yaml, et notamment la variable instance (de 1 à 2). Puis d'appliquer ce changement.
Nous avons alors un cluster PostgreSQL avec deux instances. Par défaut, la seconde instance est configurée pour fonctionner en réplication asynchrone.
Le primaire correspond au Pod postgresql-1 comme l’indique la colonne PRIMARY.

kubectl get cluster
NAME         AGE     INSTANCES   READY   STATUS                     PRIMARY
postgresql   7m46s   2           2       Cluster in healthy state   postgresql-1

Bien évidemment, cette instance a pu être déployée aussi vite car l’instance ne contenait aucune donnée.
Dans un cas réel, les données devront être récupérées depuis le primaire et copiées pour le secondaire.

kubectl delete est une commande essentielle de l'interface de ligne de commande Kubernetes (CLI) utilisée pour supprimer des ressources d'un cluster Kubernetes.
Voici un aperçu de ses fonctionnalités et de son utilisation :
- Suppression de ressources : Permet de supprimer divers types de ressources, y compris :
        Pods
        Services
        Déploiements
        Jeux de réplicas
        Cartes de configuration
        Secrets

Dans notre exemple : kubectl delete -f .\moncluster.yaml

-----------------------------
Perte de l’instance primaire
Nos deux instances fonctionnent bien jusqu’au jour où l’instance primaire connaît un problème. Véritable cauchemar du DBA, qui, malgré les différentes protections et outils mis en place, 
ne veut pas vivre cette situation. Est-ce que l’opérateur CloudNativePG permet au DBA de dormir un peu plus sur ces deux oreilles ?

kubectl delete pod postgresql-1 
pod "postgresql-1" deleted

Automatiquement, l’opérateur a promu l’instance postgresql-2 comme nouveau primaire :

kubectl get cluster  
NAME         AGE   INSTANCES   READY   STATUS                     PRIMARY
postgresql   44h   2           2       Cluster in healthy state   postgresql-2

Et en parallèle a recréé l’instance postgresql-1 :

kubectl get pod                
NAME           READY   STATUS    RESTARTS   AGE
postgresql-1   1/1     Running   0          3s
postgresql-2   1/1     Running   0          44h

L’opérateur a eu l’information que le primaire connaissait un problème, notamment via le système de Probes. Il a décidé de promouvoir le second en primaire. 
Un nouveau Pod a été recréé pour remplacer l’ancien et a pu rejoindre le cluster PostgreSQL existant. La bascule s’est donc faite automatiquement. 
Par un système de labels, les Services qui permettent d’accéder aux instances ont été mis à jour automatiquement et redirigent les connexions vers votre instance .
----------------------------------------
D’autres ressources sont quant à elles créées lors de la création d’une instance PostgreSQL.
Nous l’avons vu par exemple avec la commande "kubectl get pod" qui nous retournait deux lignes correspondant à deux Pods.
Pour n’en citer que quelques-unes : Pod, Secret, ConfigMap … et des Services.

Qu’est-ce qu’un Service ?
Tout d’abord, un Pod est volatile par définition et lorsqu’il est recréé, il obtient une nouvelle adresse IP. 
Comment un client (i.e application) pourrait-il accéder de manière pérenne à ce Pod (par exemple, une instance PostgreSQL) alors que l’adresse IP change ? 
On pourrait imaginer passer par une résolution DNS, avec la modification de l’adresse IP, mais encore faut-il que l’actualisation DNS se fasse assez rapidement…

Un Service se charge d’acheminer les connexions clientes vers l’application demandée. Les clients se connectent donc à ce composant et ce dernier choisit où 
transmettre le flux réseau en se basant sur des labels positionnés sur le ou les Pods concernés.

Ainsi, un Service est donc plus “stable” dans le temps qu’un Pod. Nos clients (i.e applications) peuvent donc utiliser son nom DNS (ou l’adresse IP) pour accéder aux applications. 
Je vous renvoie sur la documentation Kubernetes pour découvrir ce qu’est un Service et les différents types qui existent.

CloudNativePG crée trois services pour chaque cluster PostgreSQL déployé. Par exemple, pour le cluster que nous avons déployé la dernière fois, il existe :

    un service qui permet d’accéder au primaire, en lecture/écriture : postgresql-rw ;
    un service qui permet d’accéder uniquement au(x) secondaire(s), en lecture seule : postgresql-ro ;
    un service qui permet d’accéder à toutes les instances : postgresql-r.

La pratique vaut souvent plus qu’un long discours. Regardons cela avec notre cluster PostgreSQL précédent et l’application pgAdmin4.

